# 单例模式

确保某个类只有一个实例存在，并向外提供静态成员进行访问。

# 工厂模式/抽象工厂

假如要生产同一大类但细节不同的产品，比如苹果手机和华为手机，使其继承抽象产品类，然后创建一个抽象工厂类，再针对每一个产品创建相应的具体工厂类，由这些工厂类负责对应产品的生成。

# 生成器（建造者）模式

如果生成一个对象需要很多参数和步骤，则会使构造函数过于复杂，可以创建对应的builder类，将构造步骤放在builder中，并最终返回所需对象，builder类一般支持链式编程。

# 原型模式

解决类的克隆问题，由于某些类有私有成员，从外部无法复制这个类的实例，所以让该类继承一个接口，在内部实现Clone方法。

# 装饰器模式

如果要扩展一个类的功能，可以创建继承它的子类，但还有一种更灵活的方式就是装饰器模式，将对象直接嵌入一个装饰器类，作为装饰器的成员，然后就可以直接扩展其功能了。

# 适配器模式

将一个类的接口转换成客户端期待的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能一起工作。

# 代理模式

为其他对象提供一种代理以控制对某个类的访问。（VPN）

# 桥接模式

将抽象与实现解耦，使两者可以独立变化，其实也就是将多个维度分离，分别进行抽象。

# 组合模式

将类和对象组合成树形结构。有叶子节点和分支节点两种类，都继承同一接口，从上至下进行调用。

# 外观模式

给现有的系统添加一个接口，隐藏系统的复杂性，外界直接通过这个接口调用系统功能，接口会负责访问系统的各个部分并返回结果。

# 享元模式

摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。(池技术)

# 责任链模式

责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者

# 命令模式

命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

# 迭代器

迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。